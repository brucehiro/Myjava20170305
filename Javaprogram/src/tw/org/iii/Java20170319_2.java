package tw.org.iii;

//繼承、多型

public class Java20170319_2 {

	public static void main(String[] args) {
		J0319_21 b1 = new J0319_21();
		
		//因為子類別繼承父類別的屬性，所以可以用子類別的建構式來建立父類別型態的物件
		J0319_21 b2 = new J0319_22();
		
		//由於b2是J0319_21類別，所以其內容為J0319_21類別的建構式及屬性等等。但由於是用J0319_22類別來初始化b2，其中m1()被J0319_22類別overwrite，所以實作m1()時，會以J0319_22類別中的m1()來執行
		//b是m1()中的輸出值，所以下方程式會輸出b:0
		b2.m1();
		
		//雖然b2是用J0319_22初始化物件，但由於b2是屬於J0319_21，J0319_21沒有m2方法，所以b2無法呼叫J0319_22 class中的m2()。
		//b2.m2();
		
		f1(b1);
	}
	
	//J0319_22及J0319_23是由J0319_21繼承而來，因此都可以做為此函數的參考值。但由於傳入的參數設定為J0319_21類別，所以進入的參數都會被作為J0319_21類別下的物件看待。
	static void f1(J0319_21 a)
	{
		//因為被作為J0319_21看待，所以可以使用m1方法。但是實作時，要如何執行，就要看傳入的參數，其所初始化使用的類別為何，來進一步進行m1()。此為多型的一種。
		a.m1();
	}
	

}

class J0319_21
{
	int a;//a = 0
	J0319_21()
	{
		a++;
		System.out.println("J0319_21");
	}
	void m1()//沒有static，所以要有物件被建立才能使用此方法
	{
		System.out.println("J0319_21:m1()");
	}
}

class J0319_22 extends J0319_21
{
	int b;
	J0319_22()
	{
		a++;
		System.out.println("J0319_22");
	}
	void m1()
	{
		System.out.println("J0319_22:m1():b:" + b);
	}
	void m2()
	{
		System.out.println("J0319_22:m2()");
	}
}

class J0319_23 extends J0319_21
{
	
}